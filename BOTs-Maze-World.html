<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOT's Maze World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow-x: hidden;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1400px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 20px;
            position: relative;
            z-index: 1000;
        }
        
        h1 {
            text-align: center;
            font-size: 3rem;
            color: #4deeea;
            text-shadow: 0 0 20px rgba(77, 238, 234, 0.6);
            font-weight: 800;
            letter-spacing: 2px;
            margin: 0;
            flex: 1;
        }
        
        .custom-select {
            position: relative;
            display: inline-block;
            min-width: 180px;
            z-index: 10000;
        }
        
        .select-selected {
            background: linear-gradient(135deg, #2196F3, #0d47a1);
            color: white;
            padding: 15px 25px;
            border: none;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .select-selected:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
        }
        
        .select-selected:after {
            content: "â–¼";
            font-size: 16px;
            margin-left: 15px;
        }
        
        .select-items {
            position: absolute;
            background: linear-gradient(145deg, #0a0f25, #0c1430);
            top: 100%;
            left: 0;
            right: 0;
            z-index: 10000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
            margin-top: 10px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }
        
        .select-items.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .select-items div {
            padding: 18px 25px;
            color: #7fdbca;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }
        
        .select-items div:last-child {
            border-bottom: none;
        }
        
        .select-items div:hover {
            background: rgba(77, 238, 234, 0.2);
            color: #4deeea;
        }
        
        .select-items div.selected {
            background: rgba(33, 150, 243, 0.3);
            color: #4deeea;
        }
        
        .container {
            max-width: 1400px;
            width: 100%;
            background: rgba(10, 15, 30, 0.9);
            border-radius: 25px;
            padding: 35px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            margin-top: 25px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.2);
            position: relative;
            z-index: 2;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: linear-gradient(145deg, #0a0f25, #0c1430);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 200, 255, 0.15);
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-label {
            font-size: 1.2rem;
            color: #7fdbca;
            margin-bottom: 12px;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #4deeea;
            text-shadow: 0 0 10px rgba(77, 238, 234, 0.5);
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            margin: 35px 0;
            align-items: flex-start;
            position: relative;
        }
        
        .maze-section {
            flex: 1;
            display: flex;
            gap: 30px;
            position: relative;
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 25px;
            width: 280px;
            position: relative;
            z-index: 3;
        }
        
        .goal-section, .operation-section {
            background: rgba(15, 25, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        .section-title {
            color: #4deeea;
            font-size: 1.4rem;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(77, 238, 234, 0.5);
        }
        
        .section-content ul {
            padding-left: 20px;
        }
        
        .section-content li {
            margin-bottom: 10px;
            line-height: 1.6;
            font-size: 1.1rem;
        }
        
        .highlight {
            color: #4deeea;
            font-weight: 500;
        }
        
        .maze-container {
            background: rgba(15, 25, 50, 0.8);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.15);
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            position: relative;
            z-index: 3;
        }
        
        .maze-grid {
            display: grid;
            gap: 3px;
            width: fit-content;
            margin: 0 auto;
        }
        
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            position: relative;
            background: rgba(30, 40, 70, 0.7);
            border-radius: 8px;
            transition: all 0.3s ease;
            border: 2px solid rgba(100, 150, 255, 0.1);
            font-size: 22px;
        }
        
        /* ä¸åŒéš¾åº¦çš„æ ¼å­å¤§å° */
        .cell.easy {
            width: 50px;
            height: 50px;
            font-size: 26px;
        }
        
        .cell.medium {
            width: 40px;
            height: 40px;
            font-size: 22px;
        }
        
        .cell.hard {
            width: 30px;
            height: 30px;
            font-size: 18px;
        }
        
        .cell.start {
            background: linear-gradient(135deg, #4a9bff, #1a73e8);
            box-shadow: 0 0 25px rgba(74, 155, 255, 0.8);
            border: 2px solid rgba(160, 200, 255, 0.9);
            transform: scale(1.05);
        }
        
        .cell.treasure {
            background: linear-gradient(135deg, #ffd700, #ff9800);
            color: #000;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.9);
            border: 2px solid #ffecb3;
            animation: treasureGlow 2s infinite alternate;
            transform: scale(1.1);
        }
        
        @keyframes treasureGlow {
            from { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
            to { box-shadow: 0 0 40px rgba(255, 215, 0, 1); }
        }
        
        .cell.trap {
            background: linear-gradient(135deg, #ff5722, #d84315);
            box-shadow: 0 0 25px rgba(255, 87, 34, 0.7);
            border: 2px solid #ffab91;
            animation: trapPulse 1.8s infinite;
        }
        
        @keyframes trapPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
        
        .cell.wall {
            background: linear-gradient(135deg, #78909c, #546e7a);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.6);
            border: 2px solid #b0bec5;
        }
        
        .cell.coin {
            background: linear-gradient(135deg, #ff6bcb, #d500f9);
            box-shadow: 0 0 20px rgba(255, 107, 203, 0.7);
            border: 2px solid #ff80cb;
            animation: coinSpin 3s infinite linear;
            transform: scale(0.9);
        }
        
        @keyframes coinSpin {
            from { transform: rotate(0deg) scale(0.9); }
            to { transform: rotate(360deg) scale(0.9); }
        }
        
        .robot {
            width: 85%;
            height: 85%;
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 30px #4caf50;
            z-index: 10;
            animation: robotPulse 1.5s infinite;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.8);
        }
        
        .robot::before {
            content: "ğŸ¤–";
        }
        
        @keyframes robotPulse {
            0% { transform: scale(1); box-shadow: 0 0 25px #4caf50; }
            50% { transform: scale(1.15); box-shadow: 0 0 35px #4caf50; }
            100% { transform: scale(1); box-shadow: 0 0 25px #4caf50; }
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 25px;
            width: 220px;
            position: relative;
            z-index: 3;
        }
        
        .legend-items {
            background: rgba(15, 25, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        .legend-content {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        /* å³ä¾§æ»‘åŠ¨æ¡æ ·å¼ - è“è‰²ä¸»é¢˜ */
        .legend-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .legend-content::-webkit-scrollbar-track {
            background: rgba(15, 25, 50, 0.8);
            border-radius: 10px;
        }
        
        .legend-content::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #2196F3, #0d47a1);
            border-radius: 10px;
            border: 2px solid rgba(15, 25, 50, 0.8);
        }
        
        .legend-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #4deeea, #00c9ff);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1rem;
            margin-bottom: 12px;
        }
        
        .legend-item:last-child {
            margin-bottom: 0;
        }
        
        .legend-color {
            width: 25px;
            height: 25px;
            border-radius: 6px;
        }
        
        .controls {
            background: rgba(15, 25, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .btn {
            padding: 15px 20px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #2196F3, #0d47a1);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #00c853, #007e33);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #ff9800, #e65100);
            color: white;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #9c27b0, #4a148c);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f44336, #b71c1c);
            color: white;
        }
        
        .btn-disabled {
            background: linear-gradient(135deg, #9e9e9e, #616161);
            color: #bdbdbd;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .btn-disabled:hover {
            transform: none;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }
        
        .notification {
            position: fixed;
            top: 30px;
            right: 30px;
            padding: 20px 30px;
            background: linear-gradient(135deg, #00c9ff, #00838f);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            transform: translateX(200%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10000;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        /* Qå€¼è¡¨æ ·å¼ */
        .q-table-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 25, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }
        
        .q-table-container {
            background: rgba(10, 15, 30, 0.98);
            padding: 30px;
            border-radius: 20px;
            max-width: 1100px;
            width: 95%;
            max-height: 90vh;
            overflow: hidden;
            border: 2px solid rgba(100, 200, 255, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            position: relative;
        }
        
        .q-table-header {
            text-align: center;
            color: #4deeea;
            margin-bottom: 25px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(77, 238, 234, 0.6);
        }
        
        .q-table-wrapper {
            max-height: 70vh;
            overflow-y: auto;
            border-radius: 15px;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }
        
        /* Qå€¼è¡¨æ»‘åŠ¨æ¡æ ·å¼ - è“è‰²ä¸»é¢˜ */
        .q-table-wrapper::-webkit-scrollbar,
        .legend-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .q-table-wrapper::-webkit-scrollbar-track,
        .legend-content::-webkit-scrollbar-track {
            background: rgba(15, 25, 50, 0.8);
            border-radius: 10px;
        }
        
        .q-table-wrapper::-webkit-scrollbar-thumb,
        .legend-content::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #2196F3, #0d47a1);
            border-radius: 10px;
            border: 2px solid rgba(15, 25, 50, 0.8);
        }
        
        .q-table-wrapper::-webkit-scrollbar-thumb:hover,
        .legend-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #4deeea, #00c9ff);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            color: white;
            font-size: 1.1rem;
        }
        
        th {
            padding: 15px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            color: #4deeea;
            background: rgba(10, 20, 40, 0.9);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        td {
            padding: 12px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            text-align: center;
        }
        
        /* Qå€¼è¡¨å³ä¸Šè§’å…³é—­æŒ‰é’® */
        .q-table-close {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #f44336, #b71c1c);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 10001;
        }
        
        .q-table-close:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }
            
            .maze-section {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .goal-section, .operation-section,
            .legend-items, .controls {
                flex: 1;
                min-width: 300px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .btn {
                padding: 12px 15px;
                font-size: 1rem;
            }
            
            .header {
                flex-direction: column;
                gap: 20px;
            }
            
            .custom-select {
                min-width: 160px;
            }
            
            .left-panel, .right-panel {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="custom-select">
            <div class="select-selected">ç®€å•</div>
            <div class="select-items">
                <div class="selected" data-value="easy">ç®€å•</div>
                <div data-value="medium">ä¸­ç­‰</div>
                <div data-value="hard">å›°éš¾</div>
            </div>
        </div>
        
        <h1>BOT's Maze World</h1>
        
        <div class="custom-select">
            <div class="select-selected">Q-Learning</div>
            <div class="select-items">
                <div class="selected" data-value="qlearning">Q-Learning</div>
                <div data-value="sarsa">SARSA</div>
                <div data-value="expectedsarsa">Expected SARSA</div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="dashboard">
            <div class="stat-card">
                <div class="stat-label">è®­ç»ƒå›åˆ</div>
                <div class="stat-value" id="episodeCount">0</div>
                <div style="color: #7fdbca; font-size: 1.1rem;" id="maxEpisodes">/ 150</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å½“å‰æ­¥æ•°</div>
                <div class="stat-value" id="stepCount">0</div>
                <div style="color: #7fdbca; font-size: 1.1rem;" id="maxSteps">/ 500</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">ä¸Šä¸€å›åˆå¥–åŠ±</div>
                <div class="stat-value" id="lastReward">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">æ‰€ç”¨æ—¶é•¿</div>
                <div class="stat-value" id="timeElapsed">00:00:00</div>
            </div>
        </div>
        
        <div class="main-content">
            <!-- è¿·å®«å’Œå³ä¾§é¢æ¿ -->
            <div class="maze-section">
                <!-- å·¦ä¾§è¯´æ˜é¢æ¿ -->
                <div class="left-panel">
                    <div class="goal-section">
                        <h3 class="section-title">æ¸¸æˆç›®æ ‡</h3>
                        <div class="section-content">
                            <ul>
                                <li>æœºå™¨äººä»<span class="highlight">èµ·ç‚¹ğŸ </span>å‡ºå‘</li>
                                <li>é¿å¼€<span class="highlight">ç«ç„°ğŸ”¥</span>å’Œ<span class="highlight">å¢™å£ğŸ›¡ï¸</span></li>
                                <li>æ”¶é›†<span class="highlight">é‡‘å¸ğŸ’µ</span>è·å¾—å¥–åŠ±</li>
                                <li>æœ€ç»ˆåˆ°è¾¾<span class="highlight">å®è—ğŸ’°</span>å®Œæˆä»»åŠ¡</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="operation-section">
                        <h3 class="section-title">æ“ä½œè¯´æ˜</h3>
                        <div class="section-content">
                            <ul>
                                <li><span class="highlight">å¼€å§‹è®­ç»ƒ</span>ï¼šè‡ªåŠ¨å­¦ä¹ è·¯å¾„</li>
                                <li><span class="highlight">æ–°åœ°å›¾</span>ï¼šç”Ÿæˆæ–°çš„è¿·å®«</li>
                                <li><span class="highlight">æŸ¥çœ‹Qå€¼</span>ï¼šæŸ¥çœ‹å­¦ä¹ çŠ¶æ€</li>
                                <li><span class="highlight">éƒ¨ç½²ç­–ç•¥</span>ï¼šå±•ç¤ºæœ€ä¼˜è·¯å¾„</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- è¿·å®«å®¹å™¨ -->
                <div class="maze-container">
                    <div class="maze-grid" id="environmentGrid"></div>
                </div>
                
                <!-- å³ä¾§æµ®åŠ¨é¢æ¿ - å›¾ä¾‹å’ŒæŒ‰é’® -->
                <div class="right-panel">
                    <!-- å›¾ä¾‹ -->
                    <div class="legend-items">
                        <h3 class="section-title">å›¾ä¾‹</h3>
                        <div class="legend-content">
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #4a9bff, #1a73e8);"></div>
                                <span>èµ·ç‚¹ ğŸ </span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #ffd700, #ff9800);"></div>
                                <span>å®è— ğŸ’°</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #ff5722, #d84315);"></div>
                                <span>ç«ç„° ğŸ”¥</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #78909c, #546e7a);"></div>
                                <span>å¢™å£ ğŸ›¡ï¸</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: linear-gradient(135deg, #ff6bcb, #d500f9);"></div>
                                <span>é‡‘å¸ ğŸ’µ</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- æ§åˆ¶æŒ‰é’® -->
                    <div class="controls">
                        <button class="btn btn-primary" id="startBtn">å¼€å§‹è®­ç»ƒ</button>
                        <button class="btn btn-warning" id="resetBtn">æ–°åœ°å›¾</button>
                        <button class="btn btn-info" id="showQBtn">æŸ¥çœ‹Qå€¼è¡¨</button>
                        <button class="btn btn-disabled" id="deployBtn">éƒ¨ç½²ç­–ç•¥</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="notification" id="notification">è®­ç»ƒå®Œæˆ!</div>

    <script>
        // æ¸¸æˆé…ç½®
        const difficulties = {
            easy: {
                gridSize: 9,
                maxStepsPerEpisode: 500,
                maxEpisodes: 150,
                wallCount: 15,
                trapCount: 8,
                coinCount: 6,
                treasureReward: 250,
                coinReward: 20,
                cellClass: 'easy'
            },
            medium: {
                gridSize: 13,
                maxStepsPerEpisode: 1000,
                maxEpisodes: 200,
                wallCount: 30,
                trapCount: 15,
                coinCount: 10,
                treasureReward: 250,
                coinReward: 20,
                cellClass: 'medium'
            },
            hard: {
                gridSize: 19,
                maxStepsPerEpisode: 1500,
                maxEpisodes: 250,
                wallCount: 60,
                trapCount: 25,
                coinCount: 15,
                treasureReward: 250,
                coinReward: 20,
                cellClass: 'hard'
            }
        };

        let currentDifficulty = 'easy';
        let currentMethod = 'qlearning'; // é»˜è®¤ä½¿ç”¨Q-Learning
        const config = {
            actions: ["â†‘", "â†“", "â†", "â†’"],
            actionNames: ["up", "down", "left", "right"]
        };

        // å…¨å±€å˜é‡
        let Q = [];
        let gameState = {
            currentState: 0,
            lastReward: 0,
            episode: 0,
            isTraining: false,
            trainingInterval: null,
            episodeReward: 0,
            stepCount: 0,
            lastState: 0,
            collectedCoins: new Set(),
            isDeployed: false,
            deployedPath: [],
            deployedIndex: 0,
            deployInterval: null,
            lastAction: -1, // ç”¨äºSARSA
            stepInEpisode: 0,
            trainingStartTime: null,
            elapsedTime: 0,
            elapsedTimeInterval: null
        };
        let maze = {
            startState: 0,
            treasureState: 0,
            trapStates: [],
            wallStates: [],
            coinStates: [],
            gridSize: 9,
            cellClass: 'easy'
        };

        // DOMå…ƒç´ 
        const environmentGrid = document.getElementById('environmentGrid');
        const episodeCount = document.getElementById('episodeCount');
        const stepCount = document.getElementById('stepCount');
        const lastRewardEl = document.getElementById('lastReward');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const showQBtn = document.getElementById('showQBtn');
        const deployBtn = document.getElementById('deployBtn');
        const notification = document.getElementById('notification');
        const maxEpisodesEl = document.getElementById('maxEpisodes');
        const maxStepsEl = document.getElementById('maxSteps');
        const timeElapsedEl = document.getElementById('timeElapsed');
        
        // è·å–æ‰€æœ‰ä¸‹æ‹‰æ¡†å…ƒç´ 
        const selectElements = document.querySelectorAll('.custom-select');
        const difficultySelect = selectElements[0];
        const methodSelect = selectElements[1];
        
        const difficultySelected = difficultySelect.querySelector('.select-selected');
        const difficultyItems = difficultySelect.querySelector('.select-items');
        const difficultyOptions = difficultySelect.querySelectorAll('.select-items div');
        
        const methodSelected = methodSelect.querySelector('.select-selected');
        const methodItems = methodSelect.querySelector('.select-items');
        const methodOptions = methodSelect.querySelectorAll('.select-items div');

        // è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†åŠŸèƒ½
        function setupSelect(selectSelected, selectItems, selectOptions, callback) {
            selectSelected.addEventListener('click', function(e) {
                e.stopPropagation();
                // å…³é—­å…¶ä»–ä¸‹æ‹‰æ¡†
                document.querySelectorAll('.select-items').forEach(item => {
                    if (item !== selectItems) {
                        item.classList.remove('show');
                    }
                });
                selectItems.classList.toggle('show');
            });

            selectOptions.forEach(option => {
                option.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    
                    // æ›´æ–°é€‰ä¸­çŠ¶æ€
                    selectOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    // æ­£ç¡®æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬ - åªè®¾ç½®çº¯æ–‡æœ¬ï¼Œä¸æ·»åŠ é¢å¤–çš„ä¸‰è§’å½¢
                    selectSelected.textContent = text;
                    
                    // éšè—ä¸‹æ‹‰æ¡†
                    selectItems.classList.remove('show');
                    
                    // æ‰§è¡Œå›è°ƒ
                    if (callback) callback(value, text);
                });
            });
        }

        // è®¾ç½®éš¾åº¦é€‰æ‹©
        setupSelect(difficultySelected, difficultyItems, difficultyOptions, (value, text) => {
            currentDifficulty = value;
            resetGame();
            showNotification(`åˆ‡æ¢åˆ° ${text} éš¾åº¦`);
        });

        // è®¾ç½®æ–¹æ³•é€‰æ‹©
        setupSelect(methodSelected, methodItems, methodOptions, (value, text) => {
            currentMethod = value;
            showNotification(`åˆ‡æ¢åˆ° ${text} æ–¹æ³•`);
        });

        // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­ä¸‹æ‹‰æ¡†
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.custom-select')) {
                document.querySelectorAll('.select-items').forEach(item => {
                    item.classList.remove('show');
                });
            }
        });

        // ç”Ÿæˆéšæœºè¿·å®«
        function generateMaze() {
            const diff = difficulties[currentDifficulty];
            const gridSize = diff.gridSize;
            const totalCells = gridSize * gridSize;
            
            // å›ºå®šèµ·ç‚¹å’Œç»ˆç‚¹
            const start = 0;
            const treasure = totalCells - 1;
            
            // ç”Ÿæˆé™·é˜±
            const trapStates = [];
            const usedPositions = new Set([start, treasure]);
            
            for (let i = 0; i < diff.trapCount; i++) {
                let trapPos;
                do {
                    trapPos = Math.floor(Math.random() * totalCells);
                } while (usedPositions.has(trapPos) || trapPos === start || trapPos === treasure);
                trapStates.push(trapPos);
                usedPositions.add(trapPos);
            }
            
            // ç”Ÿæˆå¢™å£
            const wallStates = [];
            
            for (let i = 0; i < diff.wallCount; i++) {
                let wallPos;
                do {
                    wallPos = Math.floor(Math.random() * totalCells);
                } while (usedPositions.has(wallPos) || wallPos === start || wallPos === treasure);
                wallStates.push(wallPos);
                usedPositions.add(wallPos);
            }
            
            // ç”Ÿæˆé‡‘å¸
            const coinStates = [];
            
            for (let i = 0; i < diff.coinCount; i++) {
                let coinPos;
                do {
                    coinPos = Math.floor(Math.random() * totalCells);
                } while (usedPositions.has(coinPos) || coinPos === start || coinPos === treasure);
                coinStates.push(coinPos);
                usedPositions.add(coinPos);
            }
            
            return {
                startState: start,
                treasureState: treasure,
                trapStates: trapStates,
                wallStates: wallStates,
                coinStates: coinStates,
                gridSize: gridSize,
                cellClass: diff.cellClass
            };
        }

        // å¥–åŠ±å‡½æ•°
        function getReward(state) {
            const diff = difficulties[currentDifficulty];
            if (state === maze.treasureState) return diff.treasureReward;  // å¤§å®è—å¥–åŠ±
            if (maze.trapStates.includes(state)) return -10;  // é™·é˜±æ‰£10
            // é‡‘å¸å¥–åŠ± (åªå¥–åŠ±ä¸€æ¬¡)
            if (maze.coinStates.includes(state) && !gameState.collectedCoins.has(state)) {
                gameState.collectedCoins.add(state);
                return diff.coinReward;
            }
            // æ¯èµ°ä¸€æ ¼æƒ©ç½š1
            return -1;
        }

        // åˆå§‹åŒ–Qè¡¨
        function initializeQTable() {
            const totalCells = maze.gridSize * maze.gridSize;
            Q = Array(totalCells).fill().map(() => Array(4).fill(0));
        }

        // åˆå§‹åŒ–è¿·å®«å’Œç•Œé¢
        function initializeMaze() {
            // ç”Ÿæˆæ–°åœ°å›¾
            maze = generateMaze();
            
            // åˆå§‹åŒ–Qè¡¨
            initializeQTable();
            
            // æ¸…ç©ºç½‘æ ¼
            environmentGrid.innerHTML = '';
            
            // è®¾ç½®ç½‘æ ¼åˆ—æ•°å’Œå•å…ƒæ ¼ç±»å
            environmentGrid.style.gridTemplateColumns = `repeat(${maze.gridSize}, ${getCellSize()})`;
            
            // æ›´æ–°æœ€å¤§å€¼æ˜¾ç¤º
            const diff = difficulties[currentDifficulty];
            maxEpisodesEl.textContent = `/ ${diff.maxEpisodes}`;
            maxStepsEl.textContent = `/ ${diff.maxStepsPerEpisode}`;
            
            // åˆ›å»ºç½‘æ ¼
            const totalCells = maze.gridSize * maze.gridSize;
            for (let i = 0; i < totalCells; i++) {
                // ç¯å¢ƒç½‘æ ¼
                const envCell = document.createElement('div');
                envCell.className = `cell ${maze.cellClass}`;
                envCell.dataset.state = i;
                
                if (i === maze.startState) {
                    envCell.classList.add('start');
                    envCell.innerHTML = '<span>ğŸ </span>';
                } else if (i === maze.treasureState) {
                    envCell.classList.add('treasure');
                    envCell.innerHTML = '<span>ğŸ’°</span>';
                } else if (maze.trapStates.includes(i)) {
                    envCell.classList.add('trap');
                    envCell.innerHTML = '<span>ğŸ”¥</span>';
                } else if (maze.wallStates.includes(i)) {
                    envCell.classList.add('wall');
                    envCell.innerHTML = '<span>ğŸ›¡ï¸</span>';
                } else if (maze.coinStates.includes(i)) {
                    envCell.classList.add('coin');
                    envCell.innerHTML = '<span>ğŸ’µ</span>';
                }
                
                environmentGrid.appendChild(envCell);
            }
            
            // æ·»åŠ æ™ºèƒ½ä½“
            updateAgentPosition(maze.startState);
        }

        // è·å–å½“å‰éš¾åº¦å¯¹åº”çš„æ ¼å­å¤§å°
        function getCellSize() {
            const diff = difficulties[currentDifficulty];
            if (diff.cellClass === 'easy') return '50px';
            if (diff.cellClass === 'medium') return '40px';
            if (diff.cellClass === 'hard') return '30px';
            return '50px';
        }

        // æ›´æ–°æ™ºèƒ½ä½“ä½ç½®
        function updateAgentPosition(state) {
            // ç§»é™¤ä¹‹å‰çš„æ™ºèƒ½ä½“
            const prevAgents = document.querySelectorAll('.robot');
            prevAgents.forEach(agent => agent.remove());
            
            // æ·»åŠ æ–°çš„æ™ºèƒ½ä½“
            const cell = environmentGrid.children[state];
            if (cell) {
                const robot = document.createElement('div');
                robot.className = 'robot';
                cell.appendChild(robot);
            }
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            gameState.lastState = gameState.currentState;
            gameState.currentState = state;
            stepCount.textContent = gameState.stepCount;
            
            // å¦‚æœåˆ°è¾¾é‡‘å¸ä½ç½®ï¼Œç§»é™¤é‡‘å¸æ˜¾ç¤º
            if (maze.coinStates.includes(state) && gameState.collectedCoins.has(state)) {
                const coinCell = environmentGrid.children[state];
                if (coinCell && coinCell.classList.contains('coin')) {
                    coinCell.classList.remove('coin');
                    coinCell.innerHTML = '';
                }
            }
        }

        // çŠ¶æ€è½¬ç§»å‡½æ•°
        function step(state, actionIndex) {
            if (state === maze.treasureState) {
                return { nextState: state, reward: 0, done: true };
            }
            
            const action = config.actionNames[actionIndex];
            let nextState = state;
            const gridSize = maze.gridSize;
            const row = Math.floor(state / gridSize);
            const col = state % gridSize;
            
            switch (action) {
                case "up":
                    if (row > 0) nextState = state - gridSize;
                    break;
                case "down":
                    if (row < gridSize - 1) nextState = state + gridSize;
                    break;
                case "left":
                    if (col > 0) nextState = state - 1;
                    break;
                case "right":
                    if (col < gridSize - 1) nextState = state + 1;
                    break;
            }
            
            // æ£€æŸ¥å¢™å£
            if (maze.wallStates.includes(nextState)) {
                nextState = state; // æ’å¢™ä¸ç§»åŠ¨
            }
            
            const done = (nextState === maze.treasureState);
            return { nextState, reward: getReward(nextState), done };
        }

        // Îµ-è´ªå©ªç­–ç•¥
        function epsilonGreedy(state, epsilon = 0.15) {
            if (Math.random() < epsilon) {
                return Math.floor(Math.random() * 4);
            }
            return Q[state].indexOf(Math.max(...Q[state]));
        }

        // è®¡ç®—æœŸæœ›Qå€¼ (ç”¨äºExpected SARSA)
        function calculateExpectedQ(state, epsilon = 0.15) {
            const qValues = Q[state];
            const bestAction = qValues.indexOf(Math.max(...qValues));
            const expectedQ = new Array(4).fill(0);
            
            for (let a = 0; a < 4; a++) {
                if (a === bestAction) {
                    expectedQ[a] = (1 - epsilon + epsilon / 4) * qValues[a];
                } else {
                    expectedQ[a] = (epsilon / 4) * qValues[a];
                }
            }
            
            return expectedQ.reduce((sum, val) => sum + val, 0);
        }

        // è´ªå©ªç­–ç•¥ï¼ˆç”¨äºéƒ¨ç½²ï¼‰
        function greedyPolicy(state) {
            return Q[state].indexOf(Math.max(...Q[state]));
        }

        // æ›´æ–°Qå€¼ (Q-Learning)
        function updateQValueQLearning(state, action, reward, nextState) {
            const alpha = 0.2;
            const gamma = 0.95;
            const maxNextQ = Math.max(...Q[nextState]);
            Q[state][action] += alpha * (reward + gamma * maxNextQ - Q[state][action]);
        }

        // æ›´æ–°Qå€¼ (SARSA)
        function updateQValueSARSA(state, action, reward, nextState, nextAction) {
            const alpha = 0.2;
            const gamma = 0.95;
            const nextQ = Q[nextState][nextAction];
            Q[state][action] += alpha * (reward + gamma * nextQ - Q[state][action]);
        }

        // æ›´æ–°Qå€¼ (Expected SARSA)
        function updateQValueExpectedSARSA(state, action, reward, nextState) {
            const alpha = 0.2;
            const gamma = 0.95;
            const expectedNextQ = calculateExpectedQ(nextState);
            Q[state][action] += alpha * (reward + gamma * expectedNextQ - Q[state][action]);
        }

        // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤ºä¸º 00:00:00 (åˆ†:ç§’:æ¯«ç§’)
        function formatTime(seconds) {
            const totalMilliseconds = Math.floor(seconds * 1000);
            const minutes = Math.floor(totalMilliseconds / 60000);
            const remainingSeconds = Math.floor((totalMilliseconds % 60000) / 1000);
            const milliseconds = Math.floor((totalMilliseconds % 1000) / 10);
            
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(2, '0')}`;
        }

        // æ›´æ–°æ‰€ç”¨æ—¶é•¿æ˜¾ç¤º
        function updateElapsedTime() {
            if (gameState.trainingStartTime) {
                const currentTime = new Date();
                const elapsed = (currentTime - gameState.trainingStartTime) / 1000; // è½¬æ¢ä¸ºç§’
                gameState.elapsedTime = elapsed;
                timeElapsedEl.textContent = formatTime(elapsed);
            }
        }

        // è‡ªåŠ¨è®­ç»ƒå‡½æ•°
        function autoTrain() {
            // å¢åŠ æ­¥æ•°è®¡æ•°
            gameState.stepCount++;
            gameState.stepInEpisode++;
            stepCount.textContent = gameState.stepCount;
            
            const diff = difficulties[currentDifficulty];
            
            // å¦‚æœåˆ°è¾¾ç»ˆç‚¹æˆ–è¶…è¿‡æœ€å¤§æ­¥æ•°ï¼Œç»“æŸæœ¬è½®
            if (gameState.currentState === maze.treasureState || gameState.stepInEpisode >= diff.maxStepsPerEpisode) {
                // è®°å½•ä¸Šä¸€å›åˆå¥–åŠ±
                gameState.lastReward = gameState.episodeReward;
                lastRewardEl.textContent = gameState.episodeReward;
                
                // é‡ç½®å›åˆå¥–åŠ±
                gameState.episodeReward = 0;
                
                // å¢åŠ å›åˆæ•°
                gameState.episode++;
                updateEpisodeDisplay();
                
                // é‡ç½®æ­¥æ•°å’Œå·²æ”¶é›†é‡‘å¸
                gameState.stepCount = 0;
                gameState.stepInEpisode = 0;
                stepCount.textContent = '0';
                gameState.collectedCoins.clear();
                
                // é‡ç½®SARSAçš„ä¸Šä¸€ä¸ªåŠ¨ä½œ
                gameState.lastAction = -1;
                
                // æ£€æŸ¥æ˜¯å¦å®Œæˆè®­ç»ƒ
                if (gameState.episode >= diff.maxEpisodes) {
                    stopTraining();
                    showNotification("è®­ç»ƒå®Œæˆ!");
                    deployBtn.classList.remove('btn-disabled');
                    deployBtn.classList.add('btn-success');
                    return;
                }
                
                // é‡ç½®åˆ°èµ·ç‚¹å¹¶é‡æ–°æ˜¾ç¤ºæ‰€æœ‰é‡‘å¸ï¼ˆä¸é‡æ–°ç”Ÿæˆåœ°å›¾ï¼‰
                gameState.currentState = maze.startState;
                gameState.lastState = maze.startState;
                resetMazeForNewEpisode(); // é‡ç½®è¿·å®«æ˜¾ç¤ºä½†ä¿æŒåœ°å›¾ä¸å˜
                updateAgentPosition(maze.startState);
                return;
            }
            
            // æ ¹æ®é€‰æ‹©çš„æ–¹æ³•æ‰§è¡Œä¸åŒçš„è®­ç»ƒé€»è¾‘
            if (currentMethod === 'qlearning') {
                // Q-Learningé€»è¾‘
                const action = epsilonGreedy(gameState.currentState);
                const { nextState, reward, done } = step(gameState.currentState, action);
                updateQValueQLearning(gameState.currentState, action, reward, nextState);
                gameState.episodeReward += reward;
                updateAgentPosition(nextState);
            } else if (currentMethod === 'sarsa') {
                // SARSAé€»è¾‘
                let action;
                if (gameState.lastAction === -1) {
                    // ç¬¬ä¸€æ­¥éšæœºé€‰æ‹©åŠ¨ä½œ
                    action = epsilonGreedy(gameState.currentState);
                } else {
                    // ä½¿ç”¨ä¸Šä¸€æ­¥çš„åŠ¨ä½œ
                    action = gameState.lastAction;
                }
                
                const { nextState, reward, done } = step(gameState.currentState, action);
                const nextAction = epsilonGreedy(nextState);
                updateQValueSARSA(gameState.currentState, action, reward, nextState, nextAction);
                gameState.episodeReward += reward;
                gameState.lastAction = nextAction;
                updateAgentPosition(nextState);
            } else {
                // Expected SARSAé€»è¾‘
                const action = epsilonGreedy(gameState.currentState);
                const { nextState, reward, done } = step(gameState.currentState, action);
                updateQValueExpectedSARSA(gameState.currentState, action, reward, nextState);
                gameState.episodeReward += reward;
                updateAgentPosition(nextState);
            }
        }

        // ä¸ºæ–°å›åˆé‡ç½®è¿·å®«æ˜¾ç¤ºï¼ˆä¿æŒåœ°å›¾ä¸å˜ï¼Œé‡ç½®é‡‘å¸æ˜¾ç¤ºï¼‰
        function resetMazeForNewEpisode() {
            // æ¸…ç©ºç½‘æ ¼
            environmentGrid.innerHTML = '';
            
            // é‡æ–°åˆ›å»ºç½‘æ ¼ï¼Œæ¢å¤æ‰€æœ‰é‡‘å¸æ˜¾ç¤º
            const totalCells = maze.gridSize * maze.gridSize;
            for (let i = 0; i < totalCells; i++) {
                const envCell = document.createElement('div');
                envCell.className = `cell ${maze.cellClass}`;
                envCell.dataset.state = i;
                
                if (i === maze.startState) {
                    envCell.classList.add('start');
                    envCell.innerHTML = '<span>ğŸ </span>';
                } else if (i === maze.treasureState) {
                    envCell.classList.add('treasure');
                    envCell.innerHTML = '<span>ğŸ’°</span>';
                } else if (maze.trapStates.includes(i)) {
                    envCell.classList.add('trap');
                    envCell.innerHTML = '<span>ğŸ”¥</span>';
                } else if (maze.wallStates.includes(i)) {
                    envCell.classList.add('wall');
                    envCell.innerHTML = '<span>ğŸ›¡ï¸</span>';
                } else if (maze.coinStates.includes(i)) {
                    envCell.classList.add('coin');
                    envCell.innerHTML = '<span>ğŸ’µ</span>';
                }
                
                environmentGrid.appendChild(envCell);
            }
            
            // æ·»åŠ æ™ºèƒ½ä½“
            updateAgentPosition(maze.startState);
        }

        // æ›´æ–°å›åˆæ˜¾ç¤º
        function updateEpisodeDisplay() {
            episodeCount.textContent = gameState.episode;
        }

        // å¼€å§‹è®­ç»ƒ
        function startTraining() {
            if (gameState.isTraining) return;
            
            gameState.isTraining = true;
            startBtn.textContent = 'æš‚åœè®­ç»ƒ';
            startBtn.classList.remove('btn-primary');
            startBtn.classList.add('btn-warning');
            
            // è®°å½•è®­ç»ƒå¼€å§‹æ—¶é—´
            if (!gameState.trainingStartTime) {
                gameState.trainingStartTime = new Date();
            }
            
            // å¼€å§‹å®šæ—¶æ›´æ–°æ‰€ç”¨æ—¶é•¿
            gameState.elapsedTimeInterval = setInterval(updateElapsedTime, 10);
            
            gameState.trainingInterval = setInterval(autoTrain, 30);
        }

        // æš‚åœè®­ç»ƒ
        function stopTraining() {
            gameState.isTraining = false;
            clearInterval(gameState.trainingInterval);
            clearInterval(gameState.elapsedTimeInterval);
            startBtn.textContent = 'ç»§ç»­è®­ç»ƒ';
            startBtn.classList.remove('btn-warning');
            startBtn.classList.add('btn-primary');
        }

        // é‡ç½®æ¸¸æˆ (ç”Ÿæˆæ–°åœ°å›¾)
        function resetGame() {
            // åœæ­¢è®­ç»ƒ
            if (gameState.isTraining) {
                stopTraining();
            }
            
            // åœæ­¢éƒ¨ç½²
            if (gameState.isDeployed) {
                clearInterval(gameState.deployInterval);
                gameState.isDeployed = false;
            }
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.currentState = 0;
            gameState.lastState = 0;
            gameState.lastReward = 0;
            gameState.episode = 0;
            gameState.episodeReward = 0;
            gameState.stepCount = 0;
            gameState.stepInEpisode = 0;
            gameState.collectedCoins.clear();
            gameState.deployedPath = [];
            gameState.deployedIndex = 0;
            gameState.lastAction = -1;
            gameState.trainingStartTime = null;
            gameState.elapsedTime = 0;
            clearInterval(gameState.elapsedTimeInterval);
            
            // æ›´æ–°æ˜¾ç¤º
            lastRewardEl.textContent = '0';
            stepCount.textContent = '0';
            timeElapsedEl.textContent = '00:00:00';
            updateEpisodeDisplay();
            
            // ç¦ç”¨éƒ¨ç½²æŒ‰é’®
            deployBtn.classList.remove('btn-success');
            deployBtn.classList.add('btn-disabled');
            
            // ç”Ÿæˆæ–°åœ°å›¾
            initializeMaze();
            
            // é‡ç½®æŒ‰é’®æ–‡æœ¬
            startBtn.textContent = 'å¼€å§‹è®­ç»ƒ';
            startBtn.classList.remove('btn-warning');
            startBtn.classList.add('btn-primary');
            
            showNotification("æ–°åœ°å›¾å·²ç”Ÿæˆ!");
        }

        // æ˜¾ç¤ºé€šçŸ¥
        function showNotification(message) {
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // æ˜¾ç¤ºQå€¼è¡¨
        function showQTable() {
            const totalCells = maze.gridSize * maze.gridSize;
            let qTableHTML = `
                <div class="q-table-container">
                    <h2 class="q-table-header">Qå€¼è¡¨</h2>
                    <div class="q-table-wrapper">
                        <table>
                            <tr>
                                <th>çŠ¶æ€</th>
                                <th>â†‘ ä¸Š</th>
                                <th>â†“ ä¸‹</th>
                                <th>â† å·¦</th>
                                <th>â†’ å³</th>
                            </tr>
            `;
            
            for (let i = 0; i < totalCells; i++) {
                let bgColor, textColor;
                let qValues = Q[i];
                
                if (i === maze.treasureState) {
                    bgColor = 'linear-gradient(135deg, #ffd700, #ff9800)';
                    textColor = '#000';
                } else if (maze.trapStates.includes(i)) {
                    bgColor = 'linear-gradient(135deg, #ff5722, #d84315)';
                    textColor = '#000';
                } else if (maze.wallStates.includes(i)) {
                    bgColor = 'linear-gradient(135deg, #78909c, #546e7a)';
                    textColor = '#fff';
                } else if (maze.coinStates.includes(i)) {
                    bgColor = 'linear-gradient(135deg, #ff6bcb, #d500f9)';
                    textColor = '#fff';
                } else if (i === maze.startState) {
                    bgColor = 'linear-gradient(135deg, #4a9bff, #1a73e8)';
                    textColor = '#fff';
                } else {
                    bgColor = 'rgba(30, 40, 70, 0.8)';
                    textColor = '#4deeea';
                }
                
                qTableHTML += `<tr style="background: ${bgColor}; color: ${textColor};">
                    <td>${i}</td>
                    <td>${qValues[0].toFixed(2)}</td>
                    <td>${qValues[1].toFixed(2)}</td>
                    <td>${qValues[2].toFixed(2)}</td>
                    <td>${qValues[3].toFixed(2)}</td>
                </tr>`;
            }
            
            qTableHTML += `</table></div>
            </div>`;
            
            // åˆ›å»ºå¼¹çª—æ˜¾ç¤ºQè¡¨
            const popup = document.createElement('div');
            popup.className = 'q-table-popup';
            popup.innerHTML = qTableHTML;
            
            // æ·»åŠ å³ä¸Šè§’å…³é—­æŒ‰é’®ï¼ˆæ–‡å­—å½¢å¼ï¼‰
            const closeBtn = document.createElement('button');
            closeBtn.className = 'q-table-close';
            closeBtn.innerHTML = 'å…³é—­';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(popup);
            });
            
            popup.appendChild(closeBtn);
            
            document.body.appendChild(popup);
        }

        // è·å–å½“å‰æ–¹æ³•åç§°
        function getCurrentMethodName() {
            const methodNames = {
                'qlearning': 'Q-Learning',
                'sarsa': 'SARSA',
                'expectedsarsa': 'Expected SARSA'
            };
            return methodNames[currentMethod] || currentMethod;
        }

        // éƒ¨ç½²ç­–ç•¥æ‰§è¡Œå‡½æ•°
        function deployPolicy() {
            if (gameState.isDeployed) {
                // åœæ­¢éƒ¨ç½²
                clearInterval(gameState.deployInterval);
                gameState.isDeployed = false;
                deployBtn.textContent = 'éƒ¨ç½²ç­–ç•¥';
                deployBtn.classList.remove('btn-warning');
                deployBtn.classList.add('btn-success');
                showNotification("ç­–ç•¥éƒ¨ç½²å·²åœæ­¢");
                return;
            }
            
            // é‡ç½®åˆ°èµ·ç‚¹
            gameState.currentState = maze.startState;
            gameState.stepCount = 0;
            gameState.collectedCoins.clear();
            resetMazeForNewEpisode();
            updateAgentPosition(maze.startState);
            
            // å¼€å§‹éƒ¨ç½²
            gameState.isDeployed = true;
            deployBtn.textContent = 'åœæ­¢éƒ¨ç½²';
            deployBtn.classList.remove('btn-success');
            deployBtn.classList.add('btn-warning');
            showNotification("å¼€å§‹æ‰§è¡Œæœ€ä¼˜ç­–ç•¥");
            
            gameState.deployInterval = setInterval(() => {
                // å¦‚æœåˆ°è¾¾ç»ˆç‚¹ï¼Œåœæ­¢éƒ¨ç½²
                if (gameState.currentState === maze.treasureState) {
                    clearInterval(gameState.deployInterval);
                    gameState.isDeployed = false;
                    deployBtn.textContent = 'éƒ¨ç½²ç­–ç•¥';
                    deployBtn.classList.remove('btn-warning');
                    deployBtn.classList.add('btn-success');
                    showNotification("ç­–ç•¥æ‰§è¡Œå®Œæˆ!");
                    return;
                }
                
                // ä½¿ç”¨è´ªå©ªç­–ç•¥é€‰æ‹©åŠ¨ä½œ
                const action = greedyPolicy(gameState.currentState);
                
                // æ‰§è¡ŒåŠ¨ä½œ
                const { nextState } = step(gameState.currentState, action);
                
                // æ›´æ–°æ­¥æ•°
                gameState.stepCount++;
                stepCount.textContent = gameState.stepCount;
                
                // æ›´æ–°ä½ç½®
                updateAgentPosition(nextState);
            }, 200);
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            startBtn.addEventListener('click', () => {
                if (gameState.isTraining) {
                    stopTraining();
                } else {
                    startTraining();
                }
            });
            
            resetBtn.addEventListener('click', resetGame);
            showQBtn.addEventListener('click', showQTable);
            deployBtn.addEventListener('click', () => {
                if (!deployBtn.classList.contains('btn-disabled')) {
                    deployPolicy();
                }
            });
        }

        // åˆå§‹åŒ–åº”ç”¨
        function init() {
            initializeMaze();
            setupEventListeners();
            updateEpisodeDisplay();
            const playlist = [
                "https://raw.githubusercontent.com/Kr1shu01/ME/main/music/wish_you_were_gay.mp3",
                "https://raw.githubusercontent.com/Kr1shu01/ME/main/music/idontwannabeyouanymore.mp3",
                "https://raw.githubusercontent.com/Kr1shu01/ME/main/music/ocean_eyes.mp3"
            ];
            const audio = document.getElementById("backgroundMusic");
            // ç¬¬ä¸€æ¬¡ç‚¹å‡»åéšæœºæ’­æ”¾ä¸€é¦–
            function playRandomAudio() {
                const randomIndex = Math.floor(Math.random() * playlist.length);
                audio.src = playlist[randomIndex];
                audio.volume = 0.3;
                audio.play().catch(err => {
                    console.log("æ’­æ”¾å¤±è´¥ï¼Œè¯·å†æ¬¡ç‚¹å‡»", err);
                });
                // å»æ‰ç›‘å¬å™¨ï¼Œä»¥åç‚¹å‡»ä¸ä¼šå†è§¦å‘åˆ‡æ¢æ­Œæ›²
                document.removeEventListener("click", playRandomAudio);
            }
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener("click", playRandomAudio);
        }
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = init;
    </script>
    <audio id="backgroundMusic" loop></audio>
</body>
</html>
