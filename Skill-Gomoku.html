<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ€èƒ½äº”å­æ£‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow-x: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1400px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 20px;
            position: relative;
            z-index: 1000;
        }
        
        h1 {
            text-align: center;
            font-size: 3rem;
            color: #4deeea;
            text-shadow: 0 0 20px rgba(77, 238, 234, 0.6);
            font-weight: 800;
            letter-spacing: 2px;
            margin: 0;
            flex: 1;
        }
        
        .game-container {
            max-width: 1400px;
            width: 100%;
            background: rgba(10, 15, 30, 0.9);
            border-radius: 25px;
            padding: 35px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            margin-top: 25px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.2);
            position: relative;
            z-index: 2;
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            margin: 35px 0;
            align-items: flex-start;
            position: relative;
        }
        
        .board-wrapper {
            position: relative;
        }
        
        .chessboard {
            width: 620px; /* å¢å¤§æ£‹ç›˜ */
            height: 620px; /* å¢å¤§æ£‹ç›˜ */
            background: rgba(15, 25, 50, 0.8);
            border: 3px solid rgba(100, 200, 255, 0.3);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .cell {
            position: absolute;
            width: 30px; /* å¢å¤§æ£‹å­ */
            height: 30px; /* å¢å¤§æ£‹å­ */
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        
        .cell:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 20px rgba(77, 238, 234, 0.8);
        }
        
        .cell.black {
            background: radial-gradient(circle at 30% 30%, #2c2c2c, #000000);
            /* é»‘è‰²æ£‹å­å¤–å›´å‘å…‰æ•ˆæœ */
            outline: 2px solid rgba(77, 238, 234, 0.6);
            outline-offset: 2px;
            box-shadow: 0 0 15px rgba(77, 238, 234, 0.7), 
                        inset -3px -3px 8px rgba(0,0,0,0.5);
        }
        
        .cell.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            /* ç™½è‰²æ£‹å­å¤–å›´å‘å…‰æ•ˆæœ */
            outline: 2px solid rgba(77, 238, 234, 0.6);
            outline-offset: 2px;
            box-shadow: 0 0 15px rgba(77, 238, 234, 0.7), 
                        inset -3px -3px 8px rgba(255,255,255,0.5);
        }
        
        .grid-line {
            position: absolute;
            background: linear-gradient(90deg, #7fdbca, #4deeea, #7fdbca);
            box-shadow: 0 0 5px rgba(77, 238, 234, 0.6);
        }
        
        .horizontal-line {
            width: 100%;
            height: 2px;
        }
        
        .vertical-line {
            width: 2px;
            height: 100%;
        }
        
        .coordinate {
            position: absolute;
            font-size: 14px; /* å¢å¤§åæ ‡å­—ä½“ */
            color: #7fdbca;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(77, 238, 234, 0.7);
            user-select: none;
        }
        
        .coordinate-letter {
            bottom: 5px;
        }
        
        .coordinate-number {
            left: 5px;
        }
        
        .info-panel {
            background: rgba(15, 25, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
            min-width: 350px; /* å¢å¤§é¢æ¿ */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .current-player {
            font-size: 1.4rem; /* å¢å¤§å­—ä½“ */
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            background: rgba(10, 20, 40, 0.9);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(77, 238, 234, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.2);
            color: #7fdbca;
        }
        
        .current-player.black { 
            background: linear-gradient(45deg, rgba(0, 0, 0, 0.6), rgba(40, 40, 40, 0.6));
            color: #4deeea;
        }
        .current-player.white { 
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.4), rgba(220, 220, 220, 0.4));
            color: #0f3460;
        }
        
        .skills-section {
            margin-bottom: 20px;
        }
        
        .skills-section h3 {
            margin-bottom: 15px;
            color: #4deeea;
            font-size: 1.5rem; /* å¢å¤§æ ‡é¢˜å­—ä½“ */
            text-align: center;
            text-shadow: 0 0 10px rgba(77, 238, 234, 0.5);
            font-weight: bold;
        }
        
        .skills-container {
            display: flex;
            gap: 15px;
        }
        
        .skills-column {
            flex: 1;
        }
        
        .skill-button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #2196F3, #0d47a1);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.7;
            font-size: 1.1rem; /* å¢å¤§æŠ€èƒ½å­—ä½“ */
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .skill-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(77, 238, 234, 0.3), transparent);
            transition: 0.5s;
        }
        
        .skill-button.available {
            opacity: 1;
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6);
            animation: pulse 2s infinite;
        }
        
        .skill-button.available:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.8);
        }
        
        .skill-button.available:hover::before {
            left: 100%;
        }
        
        .skill-button.used {
            opacity: 0.3;
            cursor: not-allowed;
            background: linear-gradient(45deg, #666, #999);
        }
        
        .skill-button.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6); }
            50% { box-shadow: 0 6px 25px rgba(77, 238, 234, 0.9); }
            100% { box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6); }
        }
        
        .skill-description {
            font-size: 0.9rem; /* å¢å¤§æè¿°å­—ä½“ */
            margin-top: 5px;
            opacity: 0.9;
        }
        
        .controls {
            margin-top: 20px;
        }
        
        .control-button {
            width: 100%;
            padding: 16px;
            margin: 12px 0;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            color: #0f3460;
            font-weight: bold;
            font-size: 1.2rem; /* å¢å¤§æŒ‰é’®å­—ä½“ */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 201, 255, 0.4);
        }
        
        .control-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 201, 255, 0.6);
        }
        
        .status-message {
            margin-top: 15px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(10, 20, 40, 0.9);
            text-align: center;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem; /* å¢å¤§çŠ¶æ€å­—ä½“ */
            font-weight: bold;
            border: 1px solid rgba(100, 200, 255, 0.2);
            color: #7fdbca;
        }
        
        .winner {
            animation: winnerPulse 1s infinite;
        }
        
        @keyframes winnerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(5, 10, 25, 0.95);
        }
        
        .modal-content {
            background: rgba(10, 15, 30, 0.98);
            margin: 15% auto;
            padding: 35px;
            border-radius: 20px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(100, 200, 255, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #4deeea, #7fdbca, #4deeea);
        }
        
        .close {
            color: #4deeea;
            float: right;
            font-size: 35px;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(77, 238, 234, 0.7);
        }
        
        .notification {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg, #00c9ff, #00838f);
            color: white;
            padding: 25px 35px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            transform: translateX(200%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10000;
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .move-counter {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem; /* å¢å¤§æ­¥æ•°å­—ä½“ */
            opacity: 0.9;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(77, 238, 234, 0.5);
            color: #7fdbca;
        }
        
        .frozen {
            animation: frozenShake 0.5s infinite;
        }
        
        @keyframes frozenShake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(2deg); }
            75% { transform: translate(-50%, -50%) rotate(-2deg); }
        }
        
        /* ä»€åˆ¹æµ·æ ·å¼ - æ›´å¤§ï¼Œæ³¢æµªåœ¨å†…éƒ¨ç§»åŠ¨ */
        .shacha-hai {
            position: absolute;
            width: 140px; /* å¢å¤§ä»€åˆ¹æµ· */
            height: 100px; /* å¢å¤§ä»€åˆ¹æµ· */
            background: linear-gradient(135deg, #1e90ff, #00bfff, #4169e1);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            box-shadow: 0 6px 20px rgba(30, 144, 255, 0.8);
            border: 3px solid #0066cc;
            z-index: 5;
            overflow: hidden;
        }
        
        .shacha-hai::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 20px,
                rgba(255, 255, 255, 0.1) 20px,
                rgba(255, 255, 255, 0.1) 40px
            );
            animation: waveMove 3s linear infinite;
        }
        
        @keyframes waveMove {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        .shacha-hai-text {
            position: relative;
            z-index: 2;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
        }
        
        /* é£è¡ŒåŠ¨ç”» */
        .flying-cell {
            position: absolute;
            width: 30px; /* å¢å¤§é£è¡Œæ£‹å­ */
            height: 30px; /* å¢å¤§é£è¡Œæ£‹å­ */
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        
        .flying-black {
            background: radial-gradient(circle at 30% 30%, #2c2c2c, #000000);
            /* é£è¡Œä¸­çš„é»‘è‰²æ£‹å­ä¹Ÿå‘å…‰ */
            outline: 2px solid rgba(77, 238, 234, 0.6);
            outline-offset: 2px;
            box-shadow: 0 0 15px rgba(77, 238, 234, 0.7), 
                        inset -3px -3px 8px rgba(0,0,0,0.5);
        }
        
        .flying-white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            /* é£è¡Œä¸­çš„ç™½è‰²æ£‹å­ä¹Ÿå‘å…‰ */
            outline: 2px solid rgba(77, 238, 234, 0.6);
            outline-offset: 2px;
            box-shadow: 0 0 15px rgba(77, 238, 234, 0.7), 
                        inset -3px -3px 8px rgba(255,255,255,0.5);
        }
        
        @keyframes flyToSea {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(var(--mid-x), var(--mid-y)) scale(1.2);
                opacity: 0.9;
            }
            100% {
                transform: translate(var(--end-x), var(--end-y)) scale(0.2);
                opacity: 0;
            }
        }
        
        .flying-animation {
            animation: flyToSea 1.8s ease-in-out forwards;
        }
        
        /* ç¦ç”¨æ£‹ç›˜äº¤äº’ */
        .chessboard.disabled {
            pointer-events: none;
            opacity: 0.7;
            filter: grayscale(30%);
        }
        
        .disabled-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 20;
            display: none;
            align-items: center;
            justify-content: center;
            color: #4deeea;
            font-weight: bold;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(77, 238, 234, 0.8);
            backdrop-filter: blur(3px);
        }
        
        .chessboard.disabled .disabled-overlay {
            display: flex;
        }
        
        /* å‘å…‰æ•ˆæœ */
        .glow-effect {
            animation: glowEffect 2s infinite alternate;
        }
        
        @keyframes glowEffect {
            from { box-shadow: 0 0 10px #4deeea; }
            to { box-shadow: 0 0 25px #7fdbca, 0 0 35px #4deeea; }
        }
        
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
                align-items: center;
            }
            
            .chessboard {
                width: 100%;
                max-width: 550px;
                height: auto;
                aspect-ratio: 1/1;
            }
            
            .info-panel {
                width: 100%;
                max-width: 550px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>æŠ€èƒ½äº”å­æ£‹</h1>
    </div>
    
    <div class="game-container">
        <div class="main-content">
            <div class="board-wrapper">
                <div class="chessboard" id="chessboard">
                    <div class="disabled-overlay">æŠ€èƒ½é˜¶æ®µä¸­...</div>
                </div>
            </div>
            
            <div class="info-panel">
                <div class="current-player" id="currentPlayer">
                    å½“å‰å›åˆ: âš« é»‘æ–¹ (ç©å®¶)
                </div>
                
                <div class="move-counter" id="moveCounter">
                    é»‘æ–¹æ­¥æ•°: 0 | ç™½æ–¹æ­¥æ•°: 0
                </div>
                
                <div class="skills-section">
                    <h3>âš¡ ç‹¬é—¨ç»æŠ€</h3>
                    <div class="skills-container">
                        <div class="skills-column">
                            <button class="skill-button cooldown" id="feisha" onclick="useSkill('feisha')">
                                ğŸŒªï¸ é£æ²™èµ°çŸ³
                                <div class="skill-description">å°†å¯¹æ–¹ä¸€ä¸ªæ£‹å­ä¸¢åˆ°ä»€åˆ¹æµ·</div>
                            </button>
                            <button class="skill-button cooldown" id="liba" onclick="useSkill('liba')">
                                ğŸ‹ï¸â€â™‚ï¸ åŠ›æ‹”å±±å…®
                                <div class="skill-description">æ„¤æ€’åœ°æ€ç¿»æ£‹ç›˜ç›´æ¥è·èƒœ</div>
                            </button>
                            <button class="skill-button cooldown" id="qinna" onclick="useSkill('qinna')">
                                ğŸ¤œ æ“’æ‹¿æ“’æ‹¿
                                <div class="skill-description">ç¦æ­¢å¯¹æ–¹ã€Œé£æ²™èµ°çŸ³ã€</div>
                            </button>
                            <button class="skill-button cooldown" id="dongshan" onclick="useSkill('dongshan')">
                                ğŸŒŸ ä¸œå±±å†èµ·
                                <div class="skill-description">æ¢å¤æ£‹ç›˜åˆ°åˆå§‹æ€</div>
                            </button>
                        </div>
                        <div class="skills-column">
                            <button class="skill-button cooldown" id="jingru" onclick="useSkill('jingru')">
                                ğŸ’§ é™å¦‚æ­¢æ°´
                                <div class="skill-description">å‡ç»“æ—¶é—´å†»ç»“ç©ºæ°”</div>
                            </button>
                            <button class="skill-button cooldown" id="diaoli" onclick="useSkill('diaoli')">
                                ğŸŒ€ è°ƒç‹—ç¦»å±±
                                <div class="skill-description">éšæœºç§»åŠ¨å¯¹æ–¹æ£‹å­</div>
                            </button>
                            <button class="skill-button cooldown" id="baojie" onclick="useSkill('baojie')">
                                ğŸ§¹ æˆ‘æ˜¯ä¿æ´
                                <div class="skill-description">æ¸…é™¤å¯¹æ–¹æ‰€æœ‰æ£‹å­</div>
                            </button>
                            <button class="skill-button cooldown" id="fanZhuan" onclick="useSkill('fanZhuan')">
                                ğŸ” ä¸¤æåè½¬
                                <div class="skill-description">äº¤æ¢åŒæ–¹æ£‹å­é¢œè‰²</div>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="control-button" onclick="startNewGame()">
                        ğŸ”„ é‡æ–°å¼€å§‹
                    </button>
                </div>
                
                <div class="status-message" id="statusMessage">
                    åšå¥½å‡†å¤‡ï¼Œå±•ç°ä½ çš„æ£‹è‰ºå§!
                </div>
            </div>
        </div>
    </div>
    
    <!-- èƒœåˆ©å¼¹çª— -->
    <div id="winnerModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="winnerTitle">ğŸŒŸ è·èƒœ!</h2>
            <p id="winnerMessage"></p>
            <button class="control-button" onclick="startNewGame()" style="margin-top: 20px;">
                å†æ¥ä¸€å±€
            </button>
        </div>
    </div>
    
    <!-- æŠ€èƒ½é€šçŸ¥ -->
    <div class="notification" id="notification">
        ä½¿ç”¨æŠ€èƒ½æˆåŠŸ!
    </div>
    
    <script>
        // æ¸¸æˆçŠ¶æ€
        const BOARD_SIZE = 15;
        let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let currentPlayer = 1; // 1ä¸ºé»‘æ£‹(player), 2ä¸ºç™½æ£‹(AI)
        let gameActive = true;
        let moveCount = { 1: 0, 2: 0 }; // è®°å½•åŒæ–¹æ­¥æ•°
        let playerSkills = {
            feisha: { used: false, desc: "é£æ²™èµ°çŸ³" },
            liba: { used: false, desc: "åŠ›æ‹”å±±å…®" }, 
            qinna: { used: false, desc: "æ“’æ‹¿æ“’æ‹¿" },
            dongshan: { used: false, desc: "ä¸œå±±å†èµ·" },
            jingru: { used: false, desc: "é™å¦‚æ­¢æ°´" },
            diaoli: { used: false, desc: "è°ƒç‹—ç¦»å±±" },
            baojie: { used: false, desc: "æˆ‘æ˜¯ä¿æ´" },
            fanZhuan: { used: false, desc: "ä¸¤æåè½¬" }
        };
        let aiSkills = {
            feisha: { used: false, desc: "é£æ²™èµ°çŸ³" },
            liba: { used: false, desc: "åŠ›æ‹”å±±å…®" }, 
            qinna: { used: false, desc: "æ“’æ‹¿æ“’æ‹¿" },
            dongshan: { used: false, desc: "ä¸œå±±å†èµ·" },
            jingru: { used: false, desc: "é™å¦‚æ­¢æ°´" },
            diaoli: { used: false, desc: "è°ƒç‹—ç¦»å±±" },
            baojie: { used: false, desc: "æˆ‘æ˜¯ä¿æ´" },
            fanZhuan: { used: false, desc: "ä¸¤æåè½¬" }
        };
        let qinnaEffect = { 1: false, 2: false }; // æ“’æ‹¿æŠ€èƒ½æ•ˆæœï¼Œè°è¢«å…‹åˆ¶
        let frozenPlayer = 0; // è¢«å†»ç»“çš„ç©å®¶ï¼Œ0è¡¨ç¤ºæ— å†»ç»“
        let playerCanUseSkill = false; // æ ‡è®°ç©å®¶æ˜¯å¦å¯ä»¥ä½¿ç”¨æŠ€èƒ½
        let aiCanUseSkill = false; // æ ‡è®°AIæ˜¯å¦å¯ä»¥ä½¿ç”¨æŠ€èƒ½
        let skillTurnPhase = 0; // 0:æ­£å¸¸ä¸‹æ£‹é˜¶æ®µ, 1:æŠ€èƒ½é‡Šæ”¾é˜¶æ®µ, 2:AIæŠ€èƒ½ç­‰å¾…é˜¶æ®µ
        let nextPlayerAfterSkills = 1; // æŠ€èƒ½é‡Šæ”¾å®Œæˆåä¸‹ä¸€ä¸ªç©å®¶
        let shachaHaiElement = null; // ä»€åˆ¹æµ·å…ƒç´ 
        let lastRemovedCellColor = null; // è®°å½•æœ€åä¸€æ¬¡è¢«ç§»é™¤çš„æ£‹å­é¢œè‰²
        
        // DOMå…ƒç´ 
        const chessboard = document.getElementById('chessboard');
        const currentPlayerElement = document.getElementById('currentPlayer');
        const statusMessage = document.getElementById('statusMessage');
        const winnerModal = document.getElementById('winnerModal');
        const notification = document.getElementById('notification');
        const moveCounterElement = document.getElementById('moveCounter');
        
        // åˆå§‹åŒ–æ£‹ç›˜
        function initializeBoard() {
            chessboard.innerHTML = '<div class="disabled-overlay">æŠ€èƒ½é˜¶æ®µä¸­...</div>';
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿å’Œåæ ‡
            const cellSize = 39; // è°ƒæ•´æ ¼å­å¤§å°ä»¥é€‚åº”æ›´å¤§çš„æ£‹ç›˜
            const offsetX = 30;
            const offsetY = 30;
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            for (let i = 0; i < BOARD_SIZE; i++) {
                // æ°´å¹³çº¿
                const hLine = document.createElement('div');
                hLine.className = 'grid-line horizontal-line';
                hLine.style.top = (i * cellSize + offsetY) + 'px';
                hLine.style.left = offsetX + 'px';
                hLine.style.width = (cellSize * (BOARD_SIZE - 1)) + 'px';
                chessboard.appendChild(hLine);
                
                // å‚ç›´çº¿
                const vLine = document.createElement('div');
                vLine.className = 'grid-line vertical-line';
                vLine.style.left = (i * cellSize + offsetX) + 'px';
                vLine.style.top = offsetY + 'px';
                vLine.style.height = (cellSize * (BOARD_SIZE - 1)) + 'px';
                chessboard.appendChild(vLine);
                
                // æ•°å­—åæ ‡ï¼ˆå·¦ä¾§ï¼‰
                if (i < BOARD_SIZE) {
                    const numberCoord = document.createElement('div');
                    numberCoord.className = 'coordinate coordinate-number';
                    numberCoord.textContent = BOARD_SIZE - i;
                    numberCoord.style.left = '10px';
                    numberCoord.style.top = (i * cellSize + offsetY - 10) + 'px';
                    chessboard.appendChild(numberCoord);
                }
                
                // å­—æ¯åæ ‡ï¼ˆåº•éƒ¨ï¼‰
                if (i < BOARD_SIZE) {
                    const letterCoord = document.createElement('div');
                    letterCoord.className = 'coordinate coordinate-letter';
                    letterCoord.textContent = String.fromCharCode(65 + i);
                    letterCoord.style.left = (i * cellSize + offsetX - 8) + 'px';
                    letterCoord.style.bottom = '10px';
                    chessboard.appendChild(letterCoord);
                }
                
                // åˆ›å»ºäº¤å‰ç‚¹ï¼ˆä»…ç”¨äºç‚¹å‡»æ£€æµ‹ï¼‰
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const point = document.createElement('div');
                    point.className = 'point';
                    point.style.position = 'absolute';
                    point.style.width = '26px';
                    point.style.height = '26px';
                    point.style.left = (j * cellSize + offsetX) + 'px';
                    point.style.top = (i * cellSize + offsetY) + 'px';
                    point.style.transform = 'translate(-50%, -50%)';
                    point.style.cursor = 'pointer';
                    point.dataset.row = i;
                    point.dataset.col = j;
                    point.addEventListener('click', () => makeMove(i, j));
                    chessboard.appendChild(point);
                }
            }
            
            // æ·»åŠ ä»€åˆ¹æµ·åŒºåŸŸï¼ˆæ£‹ç›˜å¤–çš„å·¦ä¸‹è§’ï¼‰
            createShachaHai();
        }
        
        // åˆ›å»ºä»€åˆ¹æµ·ï¼ˆæ£‹ç›˜å¤–å·¦ä¸‹è§’ï¼Œæ›´å¤§ï¼‰
        function createShachaHai() {
            if (shachaHaiElement) {
                shachaHaiElement.remove();
            }
            
            // è·å–æ£‹ç›˜å®¹å™¨çš„ä½ç½®ä¿¡æ¯
            const boardWrapper = document.querySelector('.board-wrapper');
            
            shachaHaiElement = document.createElement('div');
            shachaHaiElement.className = 'shacha-hai';
            shachaHaiElement.style.left = '-150px';
            shachaHaiElement.style.bottom = '-25px';
            shachaHaiElement.style.position = 'absolute';
            
            // æ·»åŠ æ–‡å­—
            const text = document.createElement('div');
            text.className = 'shacha-hai-text';
            text.textContent = 'ä»€åˆ¹æµ·';
            shachaHaiElement.appendChild(text);
            
            boardWrapper.appendChild(shachaHaiElement);
        }
        
        // æ›´æ–°æ£‹ç›˜æ˜¾ç¤º
        function updateBoardDisplay() {
            // ç§»é™¤æ—§çš„æ£‹å­
            const oldCells = document.querySelectorAll('.cell:not(.flying-cell)');
            oldCells.forEach(cell => cell.remove());
            
            // æ·»åŠ æ–°çš„æ£‹å­
            const cellSize = 39;
            const offsetX = 30;
            const offsetY = 30;
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${board[i][j] === 1 ? 'black' : 'white'}`;
                        if (frozenPlayer === board[i][j]) {
                            cell.classList.add('frozen');
                        }
                        cell.style.left = (j * cellSize + offsetX) + 'px';
                        cell.style.top = (i * cellSize + offsetY) + 'px';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        chessboard.appendChild(cell);
                    }
                }
            }
        }
        
        // ç¦ç”¨/å¯ç”¨æ£‹ç›˜
        function toggleBoardDisable(disable) {
            if (disable) {
                chessboard.classList.add('disabled');
            } else {
                chessboard.classList.remove('disabled');
            }
        }
        
        // ä¸‹æ£‹
        function makeMove(row, col) {
            if (!gameActive || board[row][col] !== 0 || skillTurnPhase !== 0) return;
            
            // æ£€æŸ¥æ˜¯å¦è¢«å†»ç»“
            if (frozenPlayer === currentPlayer) {
                showNotification("ä½ è¢«ã€Œé™å¦‚æ­¢æ°´ã€å†»ç»“ï¼Œè·³è¿‡å›åˆ!");
                frozenPlayer = 0;
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateCurrentPlayer();
                if (currentPlayer === 2 && gameActive) {
                    setTimeout(makeAIMove, 800);
                }
                return;
            }
            
            board[row][col] = currentPlayer;
            moveCount[currentPlayer]++;
            updateMoveCounter();
            
            updateBoardDisplay();
            
            if (checkWin(row, col)) {
                showWinner(currentPlayer);
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æŠ€èƒ½è§¦å‘ç‚¹
            if (moveCount[1] % 3 === 0 && moveCount[1] > 0) {
                playerCanUseSkill = true;
            }
            if (moveCount[2] % 3 === 0 && moveCount[2] > 0) {
                aiCanUseSkill = true;
            }
            
            // å¦‚æœåŒæ–¹éƒ½è¾¾åˆ°äº†æŠ€èƒ½è§¦å‘ç‚¹ï¼Œè¿›å…¥æŠ€èƒ½é˜¶æ®µ
            if (playerCanUseSkill && aiCanUseSkill) {
                skillTurnPhase = 1; // è¿›å…¥æŠ€èƒ½é‡Šæ”¾é˜¶æ®µ
                nextPlayerAfterSkills = 1; // æŠ€èƒ½ç»“æŸåè½®åˆ°ç©å®¶
                
                // ç¦ç”¨æ£‹ç›˜
                toggleBoardDisable(true);
                
                // æ¿€æ´»ç©å®¶æŠ€èƒ½æŒ‰é’®
                updateSkillsStatus();
                updateCurrentPlayer();
                statusMessage.textContent = "åŒæ–¹éƒ½åˆ°è¾¾æŠ€èƒ½ç‚¹ï¼Œè¯·ä½ å…ˆé‡Šæ”¾æŠ€èƒ½!";
                return;
            }
            
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateCurrentPlayer();
            
            if (currentPlayer === 2 && gameActive) {
                setTimeout(makeAIMove, 800);
            }
        }
        
        // AIä¸‹æ£‹ - 100%è´´èº«æˆ˜æ–—
        function makeAIMove() {
            if (!gameActive || skillTurnPhase !== 0) return;
            
            // å¯»æ‰¾é»‘æ£‹é™„è¿‘çš„ç©ºä½ï¼ˆ100%è´´èº«æˆ˜æ–—ï¼‰
            const adjacentPositions = [];
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰é»‘æ£‹
                        const directions = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]];
                        for (let [di, dj] of directions) {
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE && board[ni][nj] === 1) {
                                adjacentPositions.push([i, j]);
                                break;
                            }
                        }
                    }
                }
            }
            
            let chosenPosition;
            if (adjacentPositions.length > 0) {
                // 100%é€‰æ‹©åœ¨ç©å®¶æ£‹å­é™„è¿‘
                chosenPosition = adjacentPositions[Math.floor(Math.random() * adjacentPositions.length)];
            } else {
                // å¦‚æœæ²¡æœ‰ç›¸é‚»ä½ç½®ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªç©ºä½ï¼ˆfallbackï¼‰
                const emptyPositions = [];
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] === 0) {
                            emptyPositions.push([i, j]);
                        }
                    }
                }
                if (emptyPositions.length > 0) {
                    chosenPosition = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                }
            }
            
            if (chosenPosition) {
                const [row, col] = chosenPosition;
                board[row][col] = 2;
                moveCount[2]++;
                updateMoveCounter();
                
                updateBoardDisplay();
                
                if (checkWin(row, col)) {
                    showWinner(2);
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æŠ€èƒ½è§¦å‘ç‚¹
                if (moveCount[1] % 3 === 0 && moveCount[1] > 0) {
                    playerCanUseSkill = true;
                }
                if (moveCount[2] % 3 === 0 && moveCount[2] > 0) {
                    aiCanUseSkill = true;
                }
                
                // å¦‚æœåŒæ–¹éƒ½è¾¾åˆ°äº†æŠ€èƒ½è§¦å‘ç‚¹ï¼Œè¿›å…¥æŠ€èƒ½é˜¶æ®µ
                if (playerCanUseSkill && aiCanUseSkill) {
                    skillTurnPhase = 1; // è¿›å…¥æŠ€èƒ½é‡Šæ”¾é˜¶æ®µ
                    nextPlayerAfterSkills = 1; // æŠ€èƒ½ç»“æŸåè½®åˆ°ç©å®¶
                    
                    // ç¦ç”¨æ£‹ç›˜
                    toggleBoardDisable(true);
                    
                    // æ¿€æ´»ç©å®¶æŠ€èƒ½æŒ‰é’®
                    updateSkillsStatus();
                    updateCurrentPlayer();
                    statusMessage.textContent = "åŒæ–¹éƒ½åˆ°è¾¾æŠ€èƒ½ç‚¹ï¼Œè¯·ä½ å…ˆé‡Šæ”¾æŠ€èƒ½!";
                    return;
                }
                
                currentPlayer = 1;
                updateCurrentPlayer();
            }
        }
        
        // æ‰§è¡Œé£æ²™èµ°çŸ³åŠ¨ç”» - ä½¿ç”¨æ­£ç¡®çš„æ£‹å­é¢œè‰²
        function executeFeishaAnimation(startRow, startCol, cellColor) {
            const cellSize = 39;
            const offsetX = 30;
            const offsetY = 30;
            
            // è·å–èµ·å§‹ä½ç½®ï¼ˆç›¸å¯¹äºæ£‹ç›˜ï¼‰
            const startX = startCol * cellSize + offsetX;
            const startY = startRow * cellSize + offsetY;
            
            // è·å–ä»€åˆ¹æµ·ä½ç½®ï¼ˆç›¸å¯¹äºæ£‹ç›˜å®¹å™¨ï¼‰
            const boardWrapper = document.querySelector('.board-wrapper');
            const seaRect = shachaHaiElement.getBoundingClientRect();
            const wrapperRect = boardWrapper.getBoundingClientRect();
            const boardRect = chessboard.getBoundingClientRect();
            
            const endX = seaRect.left - boardRect.left + seaRect.width / 2;
            const endY = seaRect.top - boardRect.top + seaRect.height / 2;
            
            // è®¡ç®—ä¸­é—´ç‚¹ï¼ˆç”¨äºæŠ›ç‰©çº¿è½¨è¿¹ï¼‰
            const midX = (startX + endX) / 2;
            const midY = Math.min(startY, endY) - 60; // å‘ä¸Šå¼¯æ›²
            
            // åˆ›å»ºé£è¡Œçš„æ£‹å­ï¼ˆä½¿ç”¨è¢«ç§»é™¤æ£‹å­çš„å®é™…é¢œè‰²ï¼‰
            const flyingCell = document.createElement('div');
            flyingCell.className = `flying-cell ${cellColor === 1 ? 'flying-black' : 'flying-white'}`;
            flyingCell.style.left = startX + 'px';
            flyingCell.style.top = startY + 'px';
            
            // è®¾ç½®åŠ¨ç”»å˜é‡
            flyingCell.style.setProperty('--mid-x', (midX - startX) + 'px');
            flyingCell.style.setProperty('--mid-y', (midY - startY) + 'px');
            flyingCell.style.setProperty('--end-x', (endX - startX) + 'px');
            flyingCell.style.setProperty('--end-y', (endY - startY) + 'px');
            flyingCell.classList.add('flying-animation');
            
            chessboard.appendChild(flyingCell);
            
            // åŠ¨ç”»ç»“æŸååˆ é™¤å…ƒç´ 
            setTimeout(() => {
                flyingCell.remove();
            }, 1800);
        }
        
        // AIä½¿ç”¨æŠ€èƒ½
        function useAISkill() {
            const availableSkills = Object.keys(aiSkills).filter(skill => !aiSkills[skill].used);
            if (availableSkills.length > 0) {
                // åªè¿‡æ»¤æ‰è¢«æ“’æ‹¿é™åˆ¶çš„é£æ²™èµ°çŸ³æŠ€èƒ½
                const filteredSkills = availableSkills.filter(skill => {
                    if (skill === 'feisha' && qinnaEffect[2]) {
                        return false; // è¢«æ“’æ‹¿æ—¶ä¸èƒ½ä½¿ç”¨é£æ²™èµ°çŸ³
                    }
                    return true;
                });
                
                if (filteredSkills.length > 0) {

                    const randomSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    
                    const opponent = 1;
                    const self = 2;
                    
                    switch(randomSkill) {
                        case 'feisha':
                            if (qinnaEffect[2]) return;
                            
                            const opponentPieces = [];
                            for (let i = 0; i < BOARD_SIZE; i++) {
                                for (let j = 0; j < BOARD_SIZE; j++) {
                                    if (board[i][j] === opponent) {
                                        opponentPieces.push([i, j]);
                                    }
                                }
                            }
                            
                            if (opponentPieces.length > 0) {
                                const [row, col] = opponentPieces[Math.floor(Math.random() * opponentPieces.length)];
                                // è®°å½•è¢«ç§»é™¤æ£‹å­çš„é¢œè‰²
                                const removedCellColor = board[row][col];
                                
                                // æ‰§è¡Œé£æ²™èµ°çŸ³åŠ¨ç”»ï¼ˆä½¿ç”¨å®é™…é¢œè‰²ï¼‰
                                executeFeishaAnimation(row, col, removedCellColor);
                                
                                // å»¶è¿Ÿç§»é™¤æ£‹å­ä»¥é…åˆåŠ¨ç”»
                                setTimeout(() => {
                                    board[row][col] = 0;
                                    updateBoardDisplay();
                                    showNotification(`ğŸŒªï¸ AIä½¿ç”¨ã€Œ${aiSkills[randomSkill].desc}ã€! ç§»é™¤äº†ä½ ä½äº(${String.fromCharCode(65+col)},${BOARD_SIZE-row})çš„æ£‹å­åˆ°ä»€åˆ¹æµ·!`);
                                    aiSkills.feisha.used = true;
                                    updateSkillsStatus();
                                }, 900);
                            }
                            break;
                            
                        case 'liba':
                            showWinner(2, "åŠ›æ‹”å±±å…®æ°”ç›–ä¸–!");
                            aiSkills.liba.used = true;
                            updateSkillsStatus();
                            showNotification(`ğŸ‹ï¸â€â™‚ï¸ AIä½¿ç”¨ã€Œ${aiSkills[randomSkill].desc}ã€! ç›´æ¥è·èƒœ!`);
                            break;
                            
                        case 'qinna':
                            qinnaEffect[1] = true;
                            showNotification(`ğŸ¤œ AIä½¿ç”¨ã€Œ${aiSkills[randomSkill].desc}ã€! ä½ æ— æ³•ä½¿ç”¨ã€Œé£æ²™èµ°çŸ³ã€æŠ€èƒ½!`);
                            aiSkills.qinna.used = true;
                            updateSkillsStatus();
                            break;
                            
                        case 'dongshan':
                            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                            updateBoardDisplay();
                            showNotification("ğŸŒŸ AIä½¿ç”¨ã€Œä¸œå±±å†èµ·ã€! æ£‹å±€é‡å½’åˆå§‹çŠ¶æ€!");
                            aiSkills.dongshan.used = true;
                            updateSkillsStatus();
                            break;
                            
                        case 'jingru':
                            frozenPlayer = 1;
                            updateBoardDisplay();
                            showNotification("ğŸ’§ AIä½¿ç”¨ã€Œé™å¦‚æ­¢æ°´ã€! ä½ ä¸‹ä¸€å›åˆæ— æ³•è¡ŒåŠ¨!");
                            aiSkills.jingru.used = true;
                            updateSkillsStatus();
                            break;
                            
                        case 'diaoli':
                            const opponentPiecesDiaoli = [];
                            for (let i = 0; i < BOARD_SIZE; i++) {
                                for (let j = 0; j < BOARD_SIZE; j++) {
                                    if (board[i][j] === opponent) {
                                        opponentPiecesDiaoli.push([i, j]);
                                    }
                                }
                            }
                            
                            if (opponentPiecesDiaoli.length > 0) {
                                // éšæœºç§»åŠ¨2-3ä¸ªæ£‹å­
                                const moveCountNum = Math.min(opponentPiecesDiaoli.length, 2 + Math.floor(Math.random() * 2));
                                const emptyPositions = [];
                                
                                for (let i = 0; i < BOARD_SIZE; i++) {
                                    for (let j = 0; j < BOARD_SIZE; j++) {
                                        if (board[i][j] === 0) {
                                            emptyPositions.push([i, j]);
                                        }
                                    }
                                }
                                
                                if (emptyPositions.length >= moveCountNum) {
                                    const movedPieces = [];
                                    for (let i = 0; i < moveCountNum; i++) {
                                        const fromIndex = Math.floor(Math.random() * opponentPiecesDiaoli.length);
                                        const toIndex = Math.floor(Math.random() * emptyPositions.length);
                                        
                                        const [fromRow, fromCol] = opponentPiecesDiaoli[fromIndex];
                                        const [toRow, toCol] = emptyPositions[toIndex];
                                        
                                        board[toRow][toCol] = opponent;
                                        board[fromRow][fromCol] = 0;
                                        
                                        movedPieces.push(`(${String.fromCharCode(65+fromCol)},${BOARD_SIZE-fromRow})â†’(${String.fromCharCode(65+toCol)},${BOARD_SIZE-toRow})`);
                                        
                                        // æ›´æ–°æ•°ç»„
                                        opponentPiecesDiaoli.splice(fromIndex, 1);
                                        emptyPositions.splice(toIndex, 1);
                                    }
                                    
                                    updateBoardDisplay();
                                    showNotification(`ğŸŒ€ AIä½¿ç”¨ã€Œè°ƒç‹—ç¦»å±±ã€! ä½ çš„æ£‹å­è¢«ç§»åŠ¨: ${movedPieces.join(', ')}`);
                                    aiSkills.diaoli.used = true;
                                    updateSkillsStatus();
                                }
                            }
                            break;
                            
                        case 'baojie':
                            // æ¸…é™¤æ‰€æœ‰é»‘æ£‹
                            let removedCount = 0;
                            for (let i = 0; i < BOARD_SIZE; i++) {
                                for (let j = 0; j < BOARD_SIZE; j++) {
                                    if (board[i][j] === opponent) {
                                        board[i][j] = 0;
                                        removedCount++;
                                    }
                                }
                            }
                            
                            if (removedCount > 0) {
                                updateBoardDisplay();
                                showNotification(`ğŸ§¹ AIä½¿ç”¨ã€Œæˆ‘æ˜¯ä¿æ´ã€! æ¸…é™¤äº†ä½ çš„${removedCount}æšæ£‹å­!`);
                                aiSkills.baojie.used = true;
                                updateSkillsStatus();
                            }
                            break;
                            
                        case 'fanZhuan':
                            // äº¤æ¢æ£‹å­é¢œè‰²
                            for (let i = 0; i < BOARD_SIZE; i++) {
                                for (let j = 0; j < BOARD_SIZE; j++) {
                                    if (board[i][j] === 1) {
                                        board[i][j] = 2;
                                    } else if (board[i][j] === 2) {
                                        board[i][j] = 1;
                                    }
                                }
                            }
                            
                            updateBoardDisplay();
                            showNotification("ğŸ” AIä½¿ç”¨ã€Œä¸¤æåè½¬ã€! åŒæ–¹æ£‹å­é¢œè‰²å·²äº’æ¢!");
                            aiSkills.fanZhuan.used = true;
                            updateSkillsStatus();
                            break;
                    }
                }
                // AIä½¿ç”¨æŠ€èƒ½åï¼Œç»“æŸæŠ€èƒ½é˜¶æ®µ
                skillTurnPhase = 0;
                playerCanUseSkill = false;
                aiCanUseSkill = false;
                
                // å¯ç”¨æ£‹ç›˜
                toggleBoardDisable(false);
                
                // æŠ€èƒ½ç»“æŸåè½®åˆ°æŒ‡å®šç©å®¶
                setTimeout(() => {
                    currentPlayer = nextPlayerAfterSkills;
                    updateCurrentPlayer();
                    statusMessage.textContent = "æŠ€èƒ½é‡Šæ”¾å®Œæˆï¼Œç»§ç»­æ¸¸æˆ!";
                    
                    if (currentPlayer === 2 && gameActive) {
                        setTimeout(makeAIMove, 800);
                    }
                }, 2200);
            }
        }
        
        // æ£€æŸ¥èƒœåˆ©
        function checkWin(row, col) {
            const player = board[row][col];
            if (player === 0) return false;
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            
            for (let [dx, dy] of directions) {
                let count = 1;
                
                // æ­£æ–¹å‘
                for (let i = 1; i < 5; i++) {
                    const newRow = row + dx * i;
                    const newCol = col + dy * i;
                    if (newRow >= 0 && newRow < BOARD_SIZE && 
                        newCol >= 0 && newCol < BOARD_SIZE && 
                        board[newRow][newCol] === player) {
                        count++;
                    } else break;
                }
                
                // åæ–¹å‘
                for (let i = 1; i < 5; i++) {
                    const newRow = row - dx * i;
                    const newCol = col - dy * i;
                    if (newRow >= 0 && newRow < BOARD_SIZE && 
                        newCol >= 0 && newCol < BOARD_SIZE && 
                        board[newRow][newCol] === player) {
                        count++;
                    } else break;
                }
                
                if (count >= 5) return true;
            }
            
            return false;
        }
        
        // ä½¿ç”¨æŠ€èƒ½
        function useSkill(skillName) {
            // åªèƒ½åœ¨æŠ€èƒ½é˜¶æ®µä½¿ç”¨æŠ€èƒ½
            if (skillTurnPhase !== 1 || !playerCanUseSkill || playerSkills[skillName].used) return;
            
            const opponent = 2;
            const self = 1;
            const isPlayerAction = true;
            
            switch(skillName) {
                case 'feisha': // é£æ²™èµ°çŸ³
                    if (qinnaEffect[self]) {
                        showNotification("ä½ è¢«ã€Œæ“’æ‹¿æ“’æ‹¿ã€å…‹åˆ¶ï¼Œæ— æ³•ä½¿ç”¨æ­¤æŠ€èƒ½!");
                        return;
                    }
                    
                    const opponentPieces = [];
                    for (let i = 0; i < BOARD_SIZE; i++) {
                        for (let j = 0; j < BOARD_SIZE; j++) {
                            if (board[i][j] === opponent) {
                                opponentPieces.push([i, j]);
                            }
                        }
                    }
                    
                    if (opponentPieces.length > 0) {
                        const [row, col] = opponentPieces[Math.floor(Math.random() * opponentPieces.length)];
                        // è®°å½•è¢«ç§»é™¤æ£‹å­çš„é¢œè‰²
                        const removedCellColor = board[row][col];
                        
                        // æ‰§è¡Œé£æ²™èµ°çŸ³åŠ¨ç”»ï¼ˆä½¿ç”¨å®é™…é¢œè‰²ï¼‰
                        executeFeishaAnimation(row, col, removedCellColor);
                        
                        // å»¶è¿Ÿç§»é™¤æ£‹å­ä»¥é…åˆåŠ¨ç”»
                        setTimeout(() => {
                            board[row][col] = 0;
                            updateBoardDisplay();
                            showNotification(`ğŸŒªï¸ã€Œ${playerSkills[skillName].desc}ã€å‘åŠ¨! ç§»é™¤äº†å¯¹æ–¹ä½äº(${String.fromCharCode(65+col)},${BOARD_SIZE-row})çš„æ£‹å­åˆ°ä»€åˆ¹æµ·!`);
                            playerSkills.feisha.used = true;
                            updateSkillsStatus();
                        }, 900);
                    } else {
                        showNotification("å¯¹æ–¹æ²¡æœ‰å¯ä»¥ç§»é™¤çš„æ£‹å­!");
                    }
                    break;
                    
                case 'liba': // åŠ›æ‹”å±±å…®
                    showWinner(self, "åŠ›æ‹”å±±å…®æ°”ç›–ä¸–!");
                    playerSkills.liba.used = true;
                    updateSkillsStatus();
                    showNotification(`ğŸ‹ï¸â€â™‚ï¸ã€Œ${playerSkills[skillName].desc}ã€å‘åŠ¨! ç›´æ¥è·èƒœ!`);
                    toggleBoardDisable(false); // è§£é™¤ç¦ç”¨
                    return;
                    
                case 'qinna': // æ“’æ‹¿æ“’æ‹¿
                    qinnaEffect[opponent] = true;
                    showNotification(`ğŸ¤œã€Œ${playerSkills[skillName].desc}ã€å‘åŠ¨! å¯¹æ–¹æ— æ³•ä½¿ç”¨ã€Œé£æ²™èµ°çŸ³ã€æŠ€èƒ½!`);
                    playerSkills.qinna.used = true;
                    updateSkillsStatus();
                    break;
                    
                case 'dongshan': // ä¸œå±±å†èµ·
                    board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                    updateBoardDisplay();
                    showNotification("ğŸŒŸã€Œä¸œå±±å†èµ·ã€å‘åŠ¨! æ£‹å±€é‡å½’åˆå§‹çŠ¶æ€!");
                    playerSkills.dongshan.used = true;
                    updateSkillsStatus();
                    break;
                    
                case 'jingru': // é™å¦‚æ­¢æ°´
                    frozenPlayer = opponent;
                    updateBoardDisplay();
                    showNotification(`ğŸ’§ã€Œ${playerSkills[skillName].desc}ã€å‘åŠ¨! å¯¹æ–¹ä¸‹å›åˆæ— æ³•è¡ŒåŠ¨!`);
                    playerSkills.jingru.used = true;
                    updateSkillsStatus();
                    break;
                    
                case 'diaoli': // è°ƒç‹—ç¦»å±±
                    const opponentPiecesDiaoli = [];
                    for (let i = 0; i < BOARD_SIZE; i++) {
                        for (let j = 0; j < BOARD_SIZE; j++) {
                            if (board[i][j] === opponent) {
                                opponentPiecesDiaoli.push([i, j]);
                            }
                        }
                    }
                    
                    if (opponentPiecesDiaoli.length > 0) {
                        // éšæœºç§»åŠ¨2-3ä¸ªæ£‹å­
                        const moveCountNum = Math.min(opponentPiecesDiaoli.length, 2 + Math.floor(Math.random() * 2));
                        const emptyPositions = [];
                        
                        for (let i = 0; i < BOARD_SIZE; i++) {
                            for (let j = 0; j < BOARD_SIZE; j++) {
                                if (board[i][j] === 0) {
                                    emptyPositions.push([i, j]);
                                }
                            }
                        }
                        
                        if (emptyPositions.length >= moveCountNum) {
                            const movedPieces = [];
                            for (let i = 0; i < moveCountNum; i++) {
                                const fromIndex = Math.floor(Math.random() * opponentPiecesDiaoli.length);
                                const toIndex = Math.floor(Math.random() * emptyPositions.length);
                                
                                const [fromRow, fromCol] = opponentPiecesDiaoli[fromIndex];
                                const [toRow, toCol] = emptyPositions[toIndex];
                                
                                board[toRow][toCol] = opponent;
                                board[fromRow][fromCol] = 0;
                                
                                movedPieces.push(`(${String.fromCharCode(65+fromCol)},${BOARD_SIZE-fromRow})â†’(${String.fromCharCode(65+toCol)},${BOARD_SIZE-toRow})`);
                                
                                // æ›´æ–°æ•°ç»„
                                opponentPiecesDiaoli.splice(fromIndex, 1);
                                emptyPositions.splice(toIndex, 1);
                            }
                            
                            updateBoardDisplay();
                            showNotification(`ğŸŒ€ã€Œ${playerSkills[skillName].desc}ã€å‘åŠ¨! å¯¹æ–¹æ£‹å­è¢«ç§»åŠ¨: ${movedPieces.join(', ')}`);
                            playerSkills.diaoli.used = true;
                            updateSkillsStatus();
                        } else {
                            showNotification("æ£‹ç›˜ç©ºé—´ä¸è¶³ï¼Œæ— æ³•ä½¿ç”¨æ­¤æŠ€èƒ½!");
                        }
                    } else {
                        showNotification("å¯¹æ–¹æ²¡æœ‰æ£‹å­å¯ä»¥ç§»åŠ¨!");
                    }
                    break;
                    
                case 'baojie': // æˆ‘æ˜¯ä¿æ´
                    // æ¸…é™¤æ‰€æœ‰å¯¹æ–¹æ£‹å­
                    let removedCount = 0;
                    for (let i = 0; i < BOARD_SIZE; i++) {
                        for (let j = 0; j < BOARD_SIZE; j++) {
                            if (board[i][j] === opponent) {
                                board[i][j] = 0;
                                removedCount++;
                            }
                        }
                    }
                    
                    if (removedCount > 0) {
                        updateBoardDisplay();
                        showNotification(`ğŸ§¹ã€Œ${playerSkills[skillName].desc}ã€å‘åŠ¨! æ¸…é™¤äº†å¯¹æ–¹çš„${removedCount}æšæ£‹å­!`);
                        playerSkills.baojie.used = true;
                        updateSkillsStatus();
                    } else {
                        showNotification("å¯¹æ–¹æ²¡æœ‰æ£‹å­å¯ä»¥æ¸…é™¤!");
                    }
                    break;
                    
                case 'fanZhuan': // ä¸¤æåè½¬
                    // äº¤æ¢æ£‹å­é¢œè‰²
                    for (let i = 0; i < BOARD_SIZE; i++) {
                        for (let j = 0; j < BOARD_SIZE; j++) {
                            if (board[i][j] === 1) {
                                board[i][j] = 2;
                            } else if (board[i][j] === 2) {
                                board[i][j] = 1;
                            }
                        }
                    }
                    
                    updateBoardDisplay();
                    showNotification("ğŸ”ã€Œä¸¤æåè½¬ã€å‘åŠ¨! åŒæ–¹æ£‹å­é¢œè‰²å·²äº’æ¢!");
                    playerSkills.fanZhuan.used = true;
                    updateSkillsStatus();
                    break;
            }
            
            // ç©å®¶ä½¿ç”¨æŠ€èƒ½åï¼Œè¿›å…¥AIæŠ€èƒ½é˜¶æ®µ
            skillTurnPhase = 2;
            playerCanUseSkill = false;
            statusMessage.textContent = "ç­‰å¾…AIé‡Šæ”¾æŠ€èƒ½...";
            
            // 1.5ç§’åAIé‡Šæ”¾æŠ€èƒ½
            setTimeout(() => {
                useAISkill();
            }, 1500);
        }
        
        // æ˜¾ç¤ºèƒœåˆ©
        function showWinner(winner, specialWinReason = "") {
            gameActive = false;
            const playerName = winner === 1 ? "é»‘æ–¹ç©å®¶" : "ç™½æ–¹AI";
            const winReason = specialWinReason || "äº”å­è¿ç !";
            
            document.getElementById('winnerTitle').textContent = winner === 1 ? "ğŸ‰ æ­å–œè·èƒœ!" : "ğŸ¤– AIè·èƒœ!";
            document.getElementById('winnerMessage').textContent = `${playerName}${specialWinReason ? `å‡­å€Ÿã€Œ${specialWinReason}ã€` : ""}è·å¾—èƒœåˆ©! ${winReason}`;
            
            winnerModal.style.display = 'block';
            statusMessage.textContent = `${playerName} è·å¾—äº†èƒœåˆ©!`;
            statusMessage.classList.add('winner');
            toggleBoardDisable(false); // è§£é™¤ç¦ç”¨
        }
        
        // å¼€å§‹æ–°æ¸¸æˆ
        function startNewGame() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            gameActive = true;
            moveCount = { 1: 0, 2: 0 };
            playerSkills = {
                feisha: { used: false, desc: "é£æ²™èµ°çŸ³" },
                liba: { used: false, desc: "åŠ›æ‹”å±±å…®" }, 
                qinna: { used: false, desc: "æ“’æ‹¿æ“’æ‹¿" },
                dongshan: { used: false, desc: "ä¸œå±±å†èµ·" },
                jingru: { used: false, desc: "é™å¦‚æ­¢æ°´" },
                diaoli: { used: false, desc: "è°ƒç‹—ç¦»å±±" },
                baojie: { used: false, desc: "æˆ‘æ˜¯ä¿æ´" },
                fanZhuan: { used: false, desc: "ä¸¤æåè½¬" }
            };
            aiSkills = {
                feisha: { used: false, desc: "é£æ²™èµ°çŸ³" },
                liba: { used: false, desc: "åŠ›æ‹”å±±å…®" }, 
                qinna: { used: false, desc: "æ“’æ‹¿æ“’æ‹¿" },
                dongshan: { used: false, desc: "ä¸œå±±å†èµ·" },
                jingru: { used: false, desc: "é™å¦‚æ­¢æ°´" },
                diaoli: { used: false, desc: "è°ƒç‹—ç¦»å±±" },
                baojie: { used: false, desc: "æˆ‘æ˜¯ä¿æ´" },
                fanZhuan: { used: false, desc: "ä¸¤æåè½¬" }
            };
            qinnaEffect = { 1: false, 2: false };
            frozenPlayer = 0;
            playerCanUseSkill = false;
            aiCanUseSkill = false;
            skillTurnPhase = 0;
            nextPlayerAfterSkills = 1;
            lastRemovedCellColor = null;
            
            updateBoardDisplay();
            updateCurrentPlayer();
            updateSkillsStatus();
            updateMoveCounter();
            toggleBoardDisable(false); // è§£é™¤ç¦ç”¨
            
            statusMessage.textContent = "åšå¥½å‡†å¤‡ï¼Œå±•ç°ä½ çš„æ£‹è‰ºå§!";
            statusMessage.className = "status-message";
            
            closeModal();
        }
        
        // æ›´æ–°å½“å‰ç©å®¶æ˜¾ç¤º
        function updateCurrentPlayer() {
            let displayText;
            if (skillTurnPhase === 1) {
                displayText = "æŠ€èƒ½é˜¶æ®µ: âš« è¯·é‡Šæ”¾æŠ€èƒ½";
            } else if (skillTurnPhase === 2) {
                displayText = "æŠ€èƒ½é˜¶æ®µ: âšª AIé‡Šæ”¾æŠ€èƒ½ä¸­";
            } else {
                displayText = currentPlayer === 1 ? 
                    "å½“å‰å›åˆ: âš« é»‘æ–¹ (ç©å®¶)" : "å½“å‰å›åˆ: âšª ç™½æ–¹ (AI)";
            }
            
            if (frozenPlayer === currentPlayer) {
                displayText += " â„ï¸(å†»ç»“ä¸­)";
            }
            
            currentPlayerElement.textContent = displayText;
            currentPlayerElement.className = `current-player ${currentPlayer === 1 ? 'black' : 'white'}`;
        }
        
        // æ›´æ–°æ­¥æ•°æ˜¾ç¤º
        function updateMoveCounter() {
            moveCounterElement.textContent = `é»‘æ–¹æ­¥æ•°: ${moveCount[1]} | ç™½æ–¹æ­¥æ•°: ${moveCount[2]}`;
        }
        
        // æ›´æ–°æŠ€èƒ½æŒ‰é’®çŠ¶æ€
        function updateSkillsStatus() {
            Object.keys(playerSkills).forEach(skill => {
                const button = document.getElementById(skill);
                button.classList.remove('available', 'used', 'cooldown');
                
                if (playerSkills[skill].used) {
                    button.classList.add('used');
                } else if (skillTurnPhase === 1 && playerCanUseSkill) {
                    button.classList.add('available');
                } else {
                    button.classList.add('cooldown');
                }
            });
        }
        
        // æ˜¾ç¤ºé€šçŸ¥
        function showNotification(message) {
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // å…³é—­æ¨¡æ€æ¡†
        function closeModal() {
            winnerModal.style.display = 'none';
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            initializeBoard();
            updateCurrentPlayer();
            updateSkillsStatus();
            updateMoveCounter();
            
            // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
            window.onclick = function(event) {
                if (event.target === winnerModal) {
                    closeModal();
                }
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = initGame;
    </script>
</body>
</html>
